#!/bin/bash

set -e

install_cert() {
        local source_prefix=$$1
        local dest_prefix=$${2:-$$1}
        local target_suffix=$${3:-crt}
        local pki_dir=/etc/kubernetes/pki

        for word in $${target_suffix} key
        do
                sudo cp $${source_prefix}.$${word} $${pki_dir}/$${dest_prefix}.$${word}
        done
        sudo chmod 0600 $${pki_dir}/$${dest_prefix}.key
        rm $${source_prefix}.key
}

# Retries a command on failure.
# $1 - the max number of attempts
# $2... - the command to run
retry() {
    local max_attempts="$${1}"; shift
    local attempt_num=1

    until "$${@}"
    do
        if [ "$${attempt_num}" -eq "$${max_attempts}" ]
        then
            echo "Attempt $${attempt_num} failed and there are no more attempts l
eft!"
            return 1
        else
            echo "Attempt $${attempt_num} failed! Trying again in $${attempt_num}
seconds..."
            sleep $(( attempt_num=attempt_num + 1 ))
        fi
    done
}

echo "Installing CA"
sudo mkdir -p /etc/kubernetes/pki/etcd
install_cert ca

echo "Running kubeadm init"
sudo kubeadm init --config $HOME/install/kubeadm.conf

echo "Installing admin config"
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

controller_key_name=brightbox-cloud-controller
controller_cert_name=cloud-controller-certs
echo "Installing Secrets of Cloud Controller"
kubectl -n kube-system create secret generic $${controller_key_name} '--from-literal=controller-client=${controller_client}' '--from-literal=controller-client-secret=${controller_client_secret}' '--from-literal=apiurl=${apiurl}'
kubectl -n kube-system create secret generic $${controller_cert_name} '--from-file=cloud-controller.crt' '--from-file=cloud-controller.key'
rm cloud-controller.key cloud-controller.crt

echo "Requesting Brightbox cloud controller activation"
#cat <<EOF | kubectl apply -f -
cat <<EOF > $HOME/install/cloud-controller.yml
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cloud-controller-manager
  namespace: kube-system
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: system:cloud-controller-manager
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: cloud-controller-manager
  namespace: kube-system
---
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    app: cloud-controller-manager
  name: cloud-controller-manager
  namespace: kube-system
data:
  cloud-controller.conf: |-
    apiVersion: v1
    kind: Config
    clusters:
    - cluster:
        certificate-authority: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        server: https://[${external_ip}]:6443
      name: default
    contexts:
    - context:
        cluster: default
        namespace: default
        user: default
      name: default
    current-context: default
    users:
    - name: default
      user:
        tokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  labels:
    k8s-app: cloud-controller-manager
  name: cloud-controller-manager
  namespace: kube-system
spec:
  selector:
    matchLabels:
      k8s-app: cloud-controller-manager
  template:
    metadata:
      labels:
        k8s-app: cloud-controller-manager
    spec:
      dnsPolicy: Default
      serviceAccountName: cloud-controller-manager
      tolerations:
        # this taint is set by all kubelets running '--cloud-provider=external'
        # so we should tolerate it to schedule the brightbox ccm
        - key: "node.cloudprovider.kubernetes.io/uninitialized"
          value: "true"
          effect: "NoSchedule"
        - key: "CriticalAddonsOnly"
          operator: "Exists"
        # cloud controller manages should be able to run on masters
        - key: "node-role.kubernetes.io/master"
          effect: NoSchedule
      containers:
      - name: cloud-controller-manager
        # for in-tree providers we use k8s.gcr.io/cloud-controller-manager
        # this can be replaced with any other image for out-of-tree providers
        image: brightbox/brightbox-cloud-controller-manager:${cloud_controller_release}
        command:
          - "/bin/brightbox-cloud-controller-manager"
          - "--cloud-provider=brightbox"
          - "--bind-address=::1"
          - "--port=0"
          - "--secure-port=10253"
          - "--configure-cloud-routes=false"
          - "--kubeconfig=/etc/kubernetes/cloud-controller.conf"
          - "--leader-elect=true"
          - --use-service-account-credentials=false
          - --tls-cert-file=/etc/kubernetes/pki/cloud-controller.crt
          - --tls-private-key-file=/etc/kubernetes/pki/cloud-controller.key
        resources:
          requests:
            cpu: 100m
            memory: 50Mi
        env:
          - name: BRIGHTBOX_CLIENT
            valueFrom:
              secretKeyRef:
                name: $${controller_key_name}
                key: controller-client
          - name: BRIGHTBOX_CLIENT_SECRET
            valueFrom:
              secretKeyRef:
                name: $${controller_key_name}
                key: controller-client-secret
          - name: BRIGHTBOX_API_URL
            valueFrom:
              secretKeyRef:
                name: $${controller_key_name}
                key: apiurl
        volumeMounts:
        - mountPath: /etc/kubernetes/cloud-controller.conf
          name: cloud-controller-conf
          readOnly: true
          subPath: cloud-controller.conf
        - mountPath: /etc/kubernetes/pki
          name: cloud-controller-certs
          readOnly: true
      hostNetwork: true
      nodeSelector:
        beta.kubernetes.io/arch: amd64
      volumes:
      - configMap:
          defaultMode: 420
          name: cloud-controller-manager
        name: cloud-controller-conf
      - secret:
          defaultMode: 420
          secretName: $${controller_cert_name}
        name: cloud-controller-certs
EOF
kubectl apply -f $HOME/install/cloud-controller.yml
